import random
import json
from flask import Blueprint, jsonify
from data_load import VIDEO_DB, users, USER_CLUSTER_DF, videos,users_list

USERS = users
user_bp = Blueprint("user", __name__)

# =================== Helper =====================
_video_lookup_cache = None


def find_user_by_id(user_id_str, users_dict):
    return users_dict.get(user_id_str)


# =================== 路由接口 ====================


from recommend_engine import load_data, Recommender  # 注意：根据你的文件名调整模块名
import os


@user_bp.route("/user/<int:user_id>/recommend")
def recommend_for_user(user_id):
    try:
        # 格式化用户ID（例如 U0001）
        str_user_id = f"U{int(user_id):04d}"

        # 加载数据（从缓存或Excel）
        excel_path = "user_behavior_7days.xlsx"
        if not os.path.exists(excel_path):
            return jsonify({"error": f"数据文件 '{excel_path}' 未找到"}), 500

        watch_df, videos_df = load_data(excel_path)

        # 初始化推荐引擎并生成推荐
        engine = Recommender(watch_df, videos_df)
        recommendations = engine.get_user_recommendations(str_user_id, top_n=100)

        # 转换为 JSON 格式，提取所需字段
        result = [
            {
                "id": int(row["id"]),
                "title": row["title"],
                "cover": row["封面地址"],
            }
            for _, row in recommendations.iterrows()
        ]

        return jsonify(result)

    except Exception as e:
        return jsonify({"error": f"生成推荐失败: {str(e)}"}), 500


@user_bp.route("/user/<int:user_id>/history")
def get_user_history_route(user_id):
    user_key = f"U{user_id:04d}"  # 转换成 "U0001" 格式
    try:
        json_data = get_user_history(user_key, USERS, videos, history_type="watched")
        return jsonify(json.loads(json_data))
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@user_bp.route("/user/<int:user_id>/likes")
def get_user_likes_route(user_id):
    user_key = f"U{user_id:04d}"  # 转换成 "U0001" 格式
    try:
        json_data = get_user_history(user_key, USERS, videos, history_type="liked")
        return jsonify(json.loads(json_data))
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@user_bp.route("/user/<int:user_id>/similar")
def get_similar_users_route(user_id):
    try:
        json_data = get_similar_users(user_id, users_list, USER_CLUSTER_DF, top_n=10)
        return jsonify(json.loads(json_data))
    except Exception as e:
        return jsonify({"error": str(e)}), 500


# =================== 主逻辑 ====================


def _build_video_lookup(videos):
    global _video_lookup_cache
    if _video_lookup_cache is None:
        print("Building video lookup cache...")
        _video_lookup_cache = {v.url: v for v in videos if v.url != "N/A"}
        print(f"Video lookup cache built with {len(_video_lookup_cache)} entries.")
    return _video_lookup_cache


def get_user_history(user_key, users_dict, videos, history_type="watched"):
    if user_key not in users_dict:
        return json.dumps({"error": f"User ID {user_key} not found."})
    if history_type not in ["watched", "liked"]:
        return json.dumps({"error": f"Invalid history_type: {history_type}."})

    try:
        target_user = users_dict[user_key]
        video_lookup = _build_video_lookup(videos)

        history_list = (
            target_user.watched_videos
            if history_type == "watched"
            else target_user.liked_videos
        )

        output_list = []
        seen_urls = set()
        for url, timestamp in reversed(history_list):
            if url in video_lookup and url not in seen_urls:
                video = video_lookup[url]
                output_list.append(
                    {
                        "id": video.url,
                        "title": video.title if video.title else "N/A",
                        "cover": video.cover_url if video.cover_url else "N/A",
                    }
                )
                seen_urls.add(url)

        return json.dumps(output_list, indent=4, ensure_ascii=False)

    except Exception as e:
        return json.dumps({"error": f"An unexpected error occurred: {str(e)}"})


def get_similar_users(user_index, users, user_clusters_df, top_n=10):
    """
    Finds users similar to the target user based on pre-computed clustering.

    Args:
        user_index (int): The index of the target user in the 'users' list.
        users (list): The list of User objects.
        user_clusters_df (pd.DataFrame): DataFrame generated by user_clustering,
                                         containing at least '用户ID' and '聚类ID' columns.
        top_n (int): The maximum number of similar user IDs to return.

    Returns:
        str: A JSON string representing a list of similar user IDs [{"id": user_id}, ...],
             or a JSON object with an error message.
    """
    # --- Input Validation ---
    if not isinstance(user_index, int) or user_index < 0 or user_index >= len(users):
        return json.dumps(
            {
                "error": f"Invalid user_index: {user_index}. Must be between 0 and {len(users)-1}."
            }
        )
    if user_clusters_df is None or user_clusters_df.empty:
        return json.dumps({"error": "User clustering data is not available or empty."})
    if not all(col in user_clusters_df.columns for col in ["用户ID", "聚类ID"]):
        return json.dumps(
            {
                "error": "User clustering DataFrame is missing required columns ('用户ID', '聚类ID')."
            }
        )

    # --- Find Similar Users ---
    try:
        target_user = users[user_index]
        target_user_id = target_user.user_id

        # Find the cluster ID of the target user
        target_cluster_rows = user_clusters_df[
            user_clusters_df["用户ID"] == target_user_id
        ]

        if target_cluster_rows.empty:
            return json.dumps(
                {
                    "error": f"Target user {target_user_id} not found in clustering results."
                }
            )

        # Handle potential multiple rows for the same user (shouldn't happen, but safe)
        target_cluster_id = target_cluster_rows["聚类ID"].iloc[0]

        # Find all users in the same cluster, excluding the target user
        similar_users_ids = user_clusters_df[
            (user_clusters_df["聚类ID"] == target_cluster_id)
            & (user_clusters_df["用户ID"] != target_user_id)
        ]["用户ID"].tolist()

        # --- Format Output ---
        # Return top_n users (the order within the cluster isn't ranked by similarity score here)
        output_list = [{"id": user_id} for user_id in similar_users_ids[:top_n]]

        return json.dumps(output_list, indent=4, ensure_ascii=False)

    except Exception as e:
        # Log the detailed error for debugging if needed
        # print(f"Error in get_similar_users: {e}")
        # traceback.print_exc()
        return json.dumps(
            {
                "error": f"An unexpected error occurred while finding similar users: {str(e)}"
            }
        )
